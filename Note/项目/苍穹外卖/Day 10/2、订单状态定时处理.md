### 需求分析与设计

![[Pasted image 20240531104643.png]]

### 代码开发

先在启动类上加上@EnableScheduling开启定时管理。

新建一个task包，里面新增一个OrderTask实现类：

```java
/**  
 * 定时任务类，定时处理订单状态  
 */  
  
@Component  
@Slf4j  
public class OrderTask {  
  
    @Autowired  
    private OrderMapper orderMapper;  
  
    @Scheduled(cron = "0 * * * * ? ") //每分钟触发一次  
    public void processTimeOutOrder() {  
        log.info("定时处理超时订单：{}", LocalDateTime.now());  
        List<Orders> ordersList = orderMapper.getByStatusAndOrderTime(Orders.PENDING_PAYMENT, LocalDateTime.now().minusMinutes(15));  
  
        if (ordersList != null && !ordersList.isEmpty()) {  
            for (Orders order : ordersList) {  
                order.setStatus(Orders.CANCELLED);  
                order.setCancelReason(MessageConstant.ORDER_OVERTIME);  
                order.setCancelTime(LocalDateTime.now());  
                orderMapper.update(order);  
            }  
        }  
    }  
  
    /**  
     * 处理一直处于派送中状态的订单  
     */  
    @Scheduled(cron = "0 0 1 * * ?") //每天凌晨1点触发一次  
    public void processDeliveryOrder(){  
        log.info("定时处理处于派送中的订单：{}",LocalDateTime.now());  
  
        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);  
  
        List<Orders> ordersList = orderMapper.getByStatusAndOrderTime(Orders.DELIVERY_IN_PROGRESS, time);  
  
        if(ordersList != null && !ordersList.isEmpty()){  
            for (Orders orders : ordersList) {  
                orders.setStatus(Orders.COMPLETED);  
                orderMapper.update(orders);  
            }  
        }  
    }  
}
```

OderMapper：

```java
/**  
 * 根据订单状态和下单时间查询订单  
 * @param status  
 * @param orderTime  
 * @return  
 */  
@Select("select * from orders where status = #{status} and order_time < #{orderTime}")  
List<Orders> getByStatusAndOrderTime(Integer status, LocalDateTime orderTime);
```

### 测试

![[Pasted image 20240531105151.png]]

![[Pasted image 20240531111349.png|550]]