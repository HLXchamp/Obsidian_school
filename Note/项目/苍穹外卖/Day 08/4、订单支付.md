### 准备工作

![[Pasted image 20240528123040.png]]

![[Pasted image 20240528123059.png|450]]

![[Pasted image 20240528123127.png]]

![[Pasted image 20240528132129.png]]

![[Pasted image 20240528132209.png]]

![[Pasted image 20240528132442.png]]

### 代码导入

![[Pasted image 20240528154637.png]]

![[Pasted image 20240528154903.png]]

在配置项application.yml中加入如下代码（了解一下）：

```yml
sky:
  wechat:
    appid: ${sky.wechat.appit}
    secret: ${sky.wechat.secret}
    mchid: ${sky.wechat.mchid}
    mchSerialNo: ${sky.wechat.mchid}
    privateKeyFilePath: ${sky.wechat.privateKeyFilePath}
    apiV3Key: ${sky.wechat.apiV3Key}
    weChatPayCertFilePath: ${sky.wechat.weChatPayCertFilePath}
    notifyUrl: ${sky.wechat.notifyUrl}
    refundNotifyUrl: ${sky.wechat.refundNotifyUrl}
```

仔细看下面参数及其对应的含义： 

![[Pasted image 20240528170802.png|450]]

在application-dev.yml文件中写入如下的代码（要注意notifyUrl和refundNotifyUrl，这两个url的前半部分都是cpolar临时生成的公网ip，因为是临时域名，所以每次生成的都会变化，以后要注意修改）：

sky:
  wechat:
    appid: 
    secret: 
    mchid: 
    mchSerialNo: 
    privateKeyFilePath: 
    apiV3Key: 
    weChatPayCertFilePat: 
    notifyUrl: https://9ea0754.r19.cpolar.top/notify/paySuccess
    refundNotifyUrl: https://9ea0754.r19.cpolar.top/notify/refundSuccess
 
 notifyUrl和refundNotifyUrl这俩地址是由微信后台请求的。

后面复制各种方法就行：

1. 将OrderController下的payment方法（订单支付）代码，复制到sky-server的controller的user下的OrderController中。

2. 将OrderService下的payment和paySuccess方法（订单支付，支付成功修改订单状态）代码，复制到sky-server的service下。

3. 将OrderServiceImpl下的payment和paySuccess方法（订单支付，支付成功修改订单状态）代码，复制到sky-server的service下的Impl中。还有注入下面的工具类。

4. 将OrderMapper下的getByNumber和update方法代码，复制到sky-server的Mapper下。

5. 把update代码复制到sky-server的resources的mapper下的OrderMapper.xml中。

6. 在UserMapper中加入getById方法：

```java
@Select("select * from user where id=#{id}")
User getById(Long userId);
```

7. 最后在sky-server的controller下创建notify包，将PayNotifyController类复制到notify包下。

#### 重点：

因为没有营业执照没办法真正支付，所以下面打算直接绕过支付，直接支付成功。

需要修改2个地方：1个是微信小程序，点击支付按钮后直接跳转支付成功。另1个是后端，要求在收到前端支付操作后，不进行任何判断，直接给数据库设置已支付状态。

下面是修改过程：

首先在微信小程序里的pay包下的index.js中将如下的代码注释掉：

![[Pasted image 20240528171032.png]]

然后把原先注释掉的重定向解除：

![[Pasted image 20240528171042.png]]

然后在IDEA中，把service/impl下的OrderServiceImpl中的如下代码注释掉：

![[Pasted image 20240528171051.png]]

同样在OrderServiceImpl中，写入如下代码，用于设置参数：

![[Pasted image 20240528171058.png]]

完整的订单支付代码如下：

```java
/**
* 订单支付
* @param ordersPaymentDTO
* @return
*/
 public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception {
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();
        User user = userMapper.getById(userId);
        Orders orders = orderMapper.getByNumber(ordersPaymentDTO.getOrderNumber());
/*        //调用微信支付接口，生成预支付交易单
        JSONObject jsonObject = weChatPayUtil.pay(
                ordersPaymentDTO.getOrderNumber(), //商户订单号
                new BigDecimal(0.01), //支付金额，单位 元
                "苍穹外卖订单", //商品描述
                user.getOpenid() //微信用户的openid
        );
 
        if (jsonObject.getString("code") != null && jsonObject.getString("code").equals("ORDERPAID")) {
            throw new OrderBusinessException("该订单已支付");
        }
*/
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("code","ORDERPAID");
        OrderPaymentVO vo = jsonObject.toJavaObject(OrderPaymentVO.class);
        vo.setPackageStr(jsonObject.getString("package"));
        Integer OrderPaidStatus = Orders.PAID;//支付状态，已支付
        Integer OrderStatus = Orders.TO_BE_CONFIRMED;  //订单状态，待接单
        LocalDateTime check_out_time = LocalDateTime.now();//更新支付时间
        orderMapper.updateStatus(OrderStatus, OrderPaidStatus, check_out_time, orders.getId());
        return vo;
    }
```

 在OrderMapper中写入如下代码：

```java
@Update("update orders set status = #{orderStatus},pay_status = #{orderPaidStatus} ,checkout_time = #{check_out_time} where id = #{id}")
void updateStatus(Integer orderStatus, Integer orderPaidStatus, LocalDateTime check_out_time, Long id);
```

现在还有一个问题就是orderId怎么获取？直接通过订单号来搜索订单的id就行！

### 测试


![[Pasted image 20240528170058.png|249]]

![[Pasted image 20240528171322.png]]

下面是我刚刚下的一单，`status==2`代表待派送，`pay_status==1`代表已支付，测试没问题。 