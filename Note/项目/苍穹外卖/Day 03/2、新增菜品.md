### 需求分析和设计

![[Pasted image 20240515231525.png]]

![[Pasted image 20240515231543.png|325]]

![[Pasted image 20240515231655.png|575]]

![[Pasted image 20240515231727.png]]

![[Pasted image 20240515231748.png]]

![[Pasted image 20240515235257.png]]

### 代码开发

#### 配置AliOSS环境和代码

在yml中加上对应值：

```java
alioss:  
  access-key-secret:
  access-key-id:
  endpoint: oss-cn-hangzhou.aliyuncs.com  
  bucket-name:
```

AliOssUtil实现类：

```java
@Data  
@AllArgsConstructor  
@Slf4j  
public class AliOssUtil {  
  
    private String endpoint;  
    private String accessKeyId;  
    private String accessKeySecret;  
    private String bucketName;  
  
    /**  
     * 文件上传  
     *  
     * @param bytes  
     * @param objectName  
     * @return  
     */  
    public String upload(byte[] bytes, String objectName) {  
  
        // 创建OSSClient实例。  
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);  
  
        try {  
            // 创建PutObject请求。  
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));  
        } catch (OSSException oe) {  
            System.out.println("Caught an OSSException, which means your request made it to OSS, "  
                    + "but was rejected with an error response for some reason.");  
            System.out.println("Error Message:" + oe.getErrorMessage());  
            System.out.println("Error Code:" + oe.getErrorCode());  
            System.out.println("Request ID:" + oe.getRequestId());  
            System.out.println("Host ID:" + oe.getHostId());  
        } catch (ClientException ce) {  
            System.out.println("Caught an ClientException, which means the client encountered "  
                    + "a serious internal problem while trying to communicate with OSS, "  
                    + "such as not being able to access the network.");  
            System.out.println("Error Message:" + ce.getMessage());  
        } finally {  
            if (ossClient != null) {  
                ossClient.shutdown();  
            }  
        }  
  
        //文件访问路径规则 https://BucketName.Endpoint/ObjectName        StringBuilder stringBuilder = new StringBuilder("https://");  
        stringBuilder  
                .append(bucketName)  
                .append(".")  
                .append(endpoint)  
                .append("/")  
                .append(objectName);  
  
        log.info("文件上传到:{}", stringBuilder.toString());  
  
        return stringBuilder.toString();  
    }  
}
```


新建一个config配置类用于创建AliOssUtil对象：

```java
/**  
 * 配置类，用于创建AliOssUtils对象  
 */  
@Configuration  
@Slf4j  
public class OssConfiguration {  
  
    @Bean  
    @ConditionalOnMissingBean //程序运行时容器中只有一个AliOssUtil类  
    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties){  
        log.info("开始创建阿里云文件上传工具类对象：{}",aliOssProperties);  
        return new AliOssUtil(aliOssProperties.getEndpoint(),  
                aliOssProperties.getAccessKeyId(),  
                aliOssProperties.getAccessKeySecret(),  
                aliOssProperties.getBucketName());  
    }  
}
```

#### 文件上传接口

新建一个CommonController类：

```java
/**  
 * 通用接口  
 */  
@RestController  
@RequestMapping("/admin/common")  
@ApiOperation("通用接口")  
@Slf4j  
public class CommonController {  
  
    @Autowired  
    private AliOssUtil aliOssUtil;  
  
    @PostMapping("/upload")  
    @ApiOperation("文件上传")  
    public Result<String> upload(MultipartFile file) { //file要与前端提供的参数名保持一致  
        log.info("文件上传：{}",file);  
  
        try {  
            //获取原始文件名  
            String originalFilename = file.getOriginalFilename();  
            //截取原始文件名的后缀 12345.png            
            String extension = originalFilename.substring(originalFilename.lastIndexOf("."));  
            //构建新文件名  
            String objectName = UUID.randomUUID().toString() + extension;  
            //文件的请求路径  
            String filePath = aliOssUtil.upload(file.getBytes(), objectName);  
            return Result.success(filePath);  
        } catch (IOException e) {  
            log.info("文件上传失败：{}",e);  
        }  
        return Result.error(MessageConstant.UPLOAD_FAILED);  
    }  
}
```


一定要看看上传的路径是否正确，不正确的话图片显示不了，要修改之前配置在yml文件中的四个值：

![[Pasted image 20240516100631.png]]
上传成功：

![[Pasted image 20240516100935.png|500]]

### 新增菜品和口味接口

新增一个DishController：

```java
/**  
 * 菜品管理  
 */  
@RestController  
@Slf4j  
@RequestMapping("/admin/dish")  
@ApiOperation("菜品管理接口")  
public class DishController {  
  
    @Autowired  
    private DishService dishService;  
  
    @PostMapping  
    @ApiOperation("新增菜品")  
    public Result save(@RequestBody DishDTO dishDTO) {  
        log.info("新增菜品：{}",dishDTO);  
        dishService.saveWithFlavor(dishDTO);  
        return Result.success();  
    }  
}
```

新增DishService，DishServiceImpl：

```java
/**  
 * 新增菜品和对应口味数据  
 * @param dishDTO  
 */  
public void saveWithFlavor(DishDTO dishDTO);
```

```java
@Service  
@Slf4j  
public class DishServiceImpl implements DishService {  
  
    @Autowired  
    private DishMapper dishMapper;  
    @Autowired  
    private DishFlavorMapper dishFlavorMapper;  
  
    @Override  
    @Transactional //事务注解，保持一致性  
    public void saveWithFlavor(DishDTO dishDTO) {  
        Dish dish = new Dish();  
        BeanUtils.copyProperties(dishDTO, dish);  
  
        //向菜品表插入1条数据，这里不要传DTO，因为DTO里有口味表的数据，所以转成dish对象传！  
        dishMapper.insert(dish);  
  
        //获取insert SQL语句生成的主键值  
        Long dishId = dish.getId();  
  
        List<DishFlavor> flavors = dishDTO.getFlavors();  
        if(flavors != null && !flavors.isEmpty()) {  
            flavors.forEach(dishFlavor -> {  
                dishFlavor.setDishId(dishId); //将dishId赋给flavors的每个对象  
            });  
            //向口味表插入n条数据  
            dishFlavorMapper.insertBatch(flavors);  
        }  
    }  
}
```

新建DishMapper与DishFlavorMapper和两个对应的xml文件来写动态SQL。

DishMapper：

```java
@Mapper  
public interface DishMapper {  
  
    /**  
     * 根据分类id查询菜品数量  
     * @param categoryId  
     * @return  
     */  
    @Select("select count(id) from dish where category_id = #{categoryId}")  
    Integer countByCategoryId(Long categoryId);  
  
    /**  
     * 插入菜品操作  
     * @param dish  
     */  
    @AutoFill(value = OperationType.INSERT)  
    void insert(Dish dish);  
}
```

```xml
<!--useGeneratedKeys="true" keyProperty="id"用于获取主键值id-->  
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">  
        insert into dish (name, category_id, price, image, description, status, create_time, update_time, create_user, update_user)  
        values (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})    
    </insert>
```


DishFlavorMapper：

```java
@Mapper  
public interface DishFlavorMapper {  
  
    //批量插入口味数据  
    void insertBatch(List<DishFlavor> flavors);  
}
```

```xml
<insert id="insertBatch">  
    insert into dish_flavor (dish_id, name, value) values  
    <foreach collection="flavors" item="df" separator=",">  
        (#{df.dishId},#{df.name},#{df.value})  
    </foreach>  
</insert>
```

难点：
- 获取insert SQL语句生成的主键值 
- foreach批量插入
### 测试

可以插入：

![[Pasted image 20240516105521.png]]

![[Pasted image 20240516110555.png]]
