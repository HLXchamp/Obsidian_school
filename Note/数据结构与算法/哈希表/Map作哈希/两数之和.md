![[Pasted image 20240305111631.png|700]]

第一种方法是显然的两个for循环暴力解法，时间复杂度是O(n^2)，见[[数据结构与算法/数组&二分查找/数组其他力扣题/两数之和#^4d708b|暴力解法]]。

第二种方法就是哈希表：
### 哈希表的使用情况

再强调一下 **什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法！

本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。这时候就应该想到使用哈希法了。

因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用<font color="#d83931">map</font>正合适**。

再来看一下使用<font color="#d83931">数组</font>和<font color="#d83931">set</font>来做哈希法的局限。

- <font color="#d83931">数组</font>的**大小是受限制**的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- <font color="#d83931">set</font>是一个集合，里面放的元素**只能是一个key**，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回 x 和 y 的下标。所以 set 也不能用。

此时就要选择另一种数据结构：map ，**map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标**。

### Map使用以及题中注意的点

Map教学可以看[Java Map 详解-CSDN博客](https://techfanyi.blog.csdn.net/article/details/131384612?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-131384612-blog-129714648.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-131384612-blog-129714648.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2)

map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）

接下来是map中key和value分别表示什么：

这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么<font color="#d83931">判断元素是否出现，这个元素就要作为key</font>，所以数组中的元素作为key，有key对应的就是value，value用来存下标。

所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。过程如下：

![过程一|600](https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png)

![过程二|600](https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png)


```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> result = new HashMap<>();
        int[] res = new int[2];
        for(int i = 0; i < nums.length; i++){
            int temp = target - nums[i];
            if(!result.containsKey(temp)){ //是result.而不是HashMap.
                result.put(nums[i], i); // 新增是put不是add
            }
            else{
                res[0] = i;
                res[1] = result.get(temp);
                return res;
            }
        }
        return res;
    }
}
```

- 时间复杂度: O(n)
- 空间复杂度: O(n)

注意事项：
- 对于map的相关操作要熟悉！！！