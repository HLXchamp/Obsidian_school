### 哈希表

**哈希表**（Hash table，也有翻译为散列表）是**根据关键码的值而直接进行访问的数据结构**。

其实直白来讲其实数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：

![哈希表1|550](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

例如要查询一个名字是否在这所学校里。要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

### 哈希函数

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

![哈希表2|650](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png)

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场：

### 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

![哈希表3|575](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png)

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。
#### 拉链法

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了。

![哈希表4|550](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png)

（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
#### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5|375](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png)

其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。

### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map（映射）

#### 1. 哈希数组（Hash Array）

哈希数组是一种数组结构，通过哈希函数将键映射到数组中的索引位置。这个结构在Java中没有直接的类实现，但它是HashSet和HashMap的基础。

##### 原理

- **哈希函数**：将键（通常是对象）转换为一个整数，这个整数是数组的索引。
- **冲突处理**：当两个键映射到同一个索引时，采用链地址法（Linked List）或开放地址法（Open Addressing）来处理冲突。

#### 2. Set集合

在Java中，Set接口是集合框架的一部分，用于存储不重复的元素。Set接口的主要实现类有HashSet、LinkedHashSet和TreeSet。每种实现都有其独特的特点和适用场景。下面详细介绍这些Set的实现、特点和常用方法。  
  
1. 接口  
Set接口扩展了Collection接口，以下是Set接口的主要特点和方法：  
  
不允许存储重复的元素。  
允许包含一个null元素（具体取决于实现）。  
不能保证元素的顺序（具体取决于实现）。  
主要方法：  
add(E e): 添加元素到集合中，如果集合中已存在该元素，返回false。  
remove(Object o): 从集合中移除指定元素，如果集合中存在该元素，返回true。  
contains(Object o): 判断集合中是否包含指定元素。  
size(): 返回集合中的元素数量。  
isEmpty(): 判断集合是否为空。  
clear(): 清空集合中的所有元素。  
iterator(): 返回集合中元素的迭代器。  
2. HashSet  
HashSet是基于哈希表实现的集合，不保证元素的顺序。  
  
特点:  
插入、删除、查找操作的时间复杂度为O(1)。  
允许包含一个null元素。  
不保证元素的迭代顺序。  
示例代码：  
java  
复制代码  
import java.util.HashSet;  
import java.util.Set;  
  
public class HashSetExample {  
    public static void main(String[] args) {  
        Set<String> hashSet = new HashSet<>();  
        hashSet.add("apple");  
        hashSet.add("banana");  
        hashSet.add("orange");  
  
        System.out.println("HashSet: " + hashSet);  
    }  
}  
3. LinkedHashSet  
LinkedHashSet是HashSet的子类，具有哈希表和链表的特性，能够维护元素的插入顺序。  
  
特点:  
保证元素的插入顺序。  
插入、删除、查找操作的时间复杂度为O(1)。  
允许包含一个null元素。  
示例代码：  
java  
复制代码  
import java.util.LinkedHashSet;  
import java.util.Set;  
  
public class LinkedHashSetExample {  
    public static void main(String[] args) {  
        Set<String> linkedHashSet = new LinkedHashSet<>();  
        linkedHashSet.add("apple");  
        linkedHashSet.add("banana");  
        linkedHashSet.add("orange");  
  
        System.out.println("LinkedHashSet: " + linkedHashSet);  
    }  
}  
4. TreeSet  
TreeSet是基于红黑树实现的有序集合，能够保证元素的自然顺序（或者根据提供的比较器排序）。  
  
特点:  
保证元素的排序顺序。  
插入、删除、查找操作的时间复杂度为O(log n)。  
不允许包含null元素。  
示例代码：  
java  
复制代码  
import java.util.Set;  
import java.util.TreeSet;  
  
public class TreeSetExample {  
    public static void main(String[] args) {  
        Set<String> treeSet = new TreeSet<>();  
        treeSet.add("orange");  
        treeSet.add("banana");  
        treeSet.add("apple");  
  
        System.out.println("TreeSet: " + treeSet);  
    }  
}  
主要实现类对比  
实现类    基于数据结构    是否保持顺序    是否允许null    主要特点  
HashSet    哈希表    否    是    插入、删除、查找操作快速，但不保证顺序  
LinkedHashSet    哈希表+链表    是    是    维护插入顺序，性能略低于HashSet  
TreeSet    红黑树    是    否    保持元素排序，插入、删除、查找操作较慢
##### 常用方法

- `add(E e)`：添加元素。
- `remove(Object o)`：删除元素。
- `contains(Object o)`：判断元素是否存在。
- `size()`：获取集合的大小。

##### 示例代码

```java
import java.util.HashSet;

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        set.add("apple");
        set.add("banana");
        set.add("cherry");

        System.out.println("Set contains apple: " + set.contains("apple"));
        System.out.println("Set size: " + set.size());

        set.remove("banana");
        System.out.println("Set contains banana: " + set.contains("banana"));
    }
}
```

#### 3. 哈希映射（HashMap）

`HashMap`是一个键值对的集合，允许快速的查找、插入和删除操作。键和值都可以是任意的对象。

##### 常用方法

- `put(K key, V value)`：添加键值对。
- `get(Object key)`：根据键获取值。
- `remove(Object key)`：根据键删除键值对。
- `containsKey(Object key)`：判断键是否存在。
- `containsValue(Object value)`：判断值是否存在。
- `size()`：获取映射的大小。

##### 示例代码

```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        map.put("apple", 1);
        map.put("banana", 2);
        map.put("cherry", 3);

        System.out.println("Value for key 'apple': " + map.get("apple"));
        System.out.println("Map size: " + map.size());

        map.remove("banana");
        System.out.println("Map contains key 'banana': " + map.containsKey("banana"));
    }
}
```

#### 小结

- **哈希数组**：直接使用数组实现哈希表的基础结构。
- **HashSet**：基于哈希表实现的集合，具有快速的查找、插入和删除操作。
- **HashMap**：基于哈希表实现的键值对集合，允许根据键快速查找、插入和删除值。

这些哈希结构在Java中的广泛应用，主要是因为其高效的操作性能。了解和掌握它们的使用对提高程序的性能有很大帮助。