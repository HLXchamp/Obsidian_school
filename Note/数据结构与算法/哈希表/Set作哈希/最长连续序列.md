![[Pasted image 20240727152929.png|675]]

#### 整体思路

都要用set去重！

#### 方法一：用到排序

先用TreeSet将nums数组去重并排序形成一个新数组arr，然后for循环遍历新数组，如果`arr[i + 1]`等于`arr[i] + 1`，那就说明是连续序列，记录下来并与max比较。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length == 0){ // 特殊情况
            return 0;
        }
        Set<Integer> set = new TreeSet<>();
        for(int i : nums){
            set.add(i);
        }
        int[] arr = new int[set.size()]; 
        int index = 0;
        for (int num : set) {
            arr[index++] = num; 
        }
        int max = 1;
        int temp = 1;
        for(int i = 0; i < arr.length - 1; i++){
            int j = i + 1;
            if(arr[j] == arr[i] + 1){
                temp++;
            } else {
                max = Math.max(max, temp);
                temp = 1;
            }
        }
        return Math.max(max, temp);
    }
}
```

- 时间复杂度：**O(nlogn)**，`TreeSet`是基于红黑树实现的，每次插入操作的时间复杂度是O(log n)。
- 空间复杂度：**O(n)**。

#### 方法二：不用排序，降低时间复杂度

还是先用set去重形成新数组，之后遍历新数组，**每个数都判断一次这个数是不是连续序列的开头那个数**。不是的话直接跳过，是的话再统计最长连续数组。

以题解中的序列举例: 

`[100，4，200，1，3，4，2]`  去重后的哈希序列为： `[100，4，200，1，3，2]`  

按照上面逻辑进行判断：

1. 元素100是开头，因为没有99，且以100开头的序列长度为1
2. 元素4不是开头，因为有3存在，过，
3. 元素200是开头，因为没有199，且以200开头的序列长度为1
4. 元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
5. 元素3不是开头，因为2存在，过，
6. 元素2不是开头，因为1存在，过。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        Set<Integer> set = new HashSet<>();
        for (int i : nums) {
            set.add(i);
        }
        int max = 1;
        for (int num : set) { // 直接在set里找会少一些元素
            int temp = 1;     // 每遍历一次连续队列后要重置temp
            if (set.contains(num - 1)) { // 如果包含就说明不是第一个元素
                continue;
            } else {
                int cur = num;
                while (set.contains(cur + 1)) {
                    temp++;
                    cur = cur + 1;  // 每一次cur要加1，不加的话会死循环
                }
                max = Math.max(max, temp);
            }
        }
        return max;
    }
}
```

注：

- 每遍历一次连续队列后要重置temp；
- 如果set中包含此元素值 - 1 的元素就说明不是第一个元素，直接跳过；
- 统计连续序列的while里每一次cur要加1，不加的话会死循环！