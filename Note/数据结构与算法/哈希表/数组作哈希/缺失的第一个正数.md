![[Pasted image 20240711095010.png|475]]

#### 方法一：新建一个数组作为哈希数组保存出现过的正数

- `max = Math.min(max, len);`这个是本题的关键，**如果max比len还大，那1~len中一定有一个正数不在nums数组里**，故取max和len的最小值就行！
- max最先要声明为0，因为>0的数才赋值；
- 更新temp数组时要加上`nums[i] <= max`这个条件，不然会越界；
- 如果所有正整数都存在，返回max+1。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        int max = 0; // 初始化为最小值0，小于0的都不放进去
        for (int i = 0; i < len; i++) {
            if (nums[i] > max) {
                max = nums[i]; // 更新最大值
            }
        }
        max = Math.min(max, len); // 限制max为数组长度或更小

        int[] temp = new int[max + 1]; // 创建计数数组
        for (int i = 0; i < len; i++) {
            if (nums[i] > 0 && nums[i] <= max) {
                temp[nums[i]]++; // 只计数1到max之间的正整数
            }
        }

        for (int i = 1; i < max + 1; i++) { // 从1开始检查到max+1
            if (temp[i] == 0) {
                return i; // 返回第一个缺失的正整数
            }
        }
        return max + 1; // 如果所有正整数都存在，返回max+1
    }
}
```

#### 方法二：原地哈希

![[Pasted image 20240714114253.png]]

- 整理数组时，一定是用`while`，因为交换后的数可能也不满足整理的要求，可能还要再交换！
- 整理时判断的一定是`nums[i] != nums[nums[i] - 1]`而不是`nums[i] != i + 1`，如果被交换的数和要交换的数相同就会陷入死循环！
- 原地哈希就不用计算`max`了，直接用数组长度`len`就行。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        int temp = 0;
        for (int i = 0; i < len; i++) { // 整理数组
            while (nums[i] > 0 && nums[i] <= len && nums[i] != nums[nums[i] - 1]) { // 一定要用while
                temp = nums[i];
                nums[i] = nums[nums[i] - 1];
                nums[temp - 1] = temp;
            }
        }

        for (int i = 0; i < len; i++) { // 从1开始检查到len+1
            if (nums[i] != i + 1) { // 最后比较就不用0来比较了，用i+1
                return i + 1; // 返回第一个缺失的正整数
            }
        }
        return len + 1; // 如果所有正整数都存在，返回len+1
    }
}
```
