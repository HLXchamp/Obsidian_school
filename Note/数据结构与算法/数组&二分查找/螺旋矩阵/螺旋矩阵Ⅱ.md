![[Pasted image 20240119104456.png]]

像之前的二分法一样，也要有**循环不变量**，我们这里画一条边都要坚持一致的**左闭右开**，这样四条边遍历的方法都是一样的。

![[Pasted image 20240119163522.png|300]]

遍历圈数应该是**n/2**向下取整（找规律），其中n如果是奇数，遍历完n/2次后就只剩下最中间的一个元素了。

对于每一条边，遍历的时候还要控制它的**终止位置**（offset），因为每一次遍历圈数后的终止位置要变。然后对于每一条边分别遍历即可。赋值的基本思路是设定一个**计数值**（count）从1开始每遍历一个数就加一。

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    // 初始化返回的结果数组的大小
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    
    // 初始化返回结果数组 arr
    int** arr = (int**)malloc(sizeof(int*) * n);
    int i;
    for (i = 0; i < n; i++) {
        arr[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }

    int startx = 0; // 起始边，在单圈循环时不变
    int starty = 0;
    int offset = 1;
    int count = 1;
    int loop = n / 2; // 应该转 n/2 圈

    while (loop) { 
        int i = startx;
        int j = starty;
        // 从左到右
        for (; j < n - offset; j++) {
            arr[startx][j] = count++;
        }
        // 从上到下
        for (; i < n - offset; i++) {
            arr[i][j] = count++; // 上一轮的 j 已经循环到最右边了，可以直接用 j
        }
        // 从右到左
        for (; j > starty; j--) { // 此时 i 和 j 都是最大值了
            arr[i][j] = count++; 
        }
        // 从下到上
        for (; i > startx; i--) {
            arr[i][j] = count++;
        }
        startx++;
        starty++;
        offset++;
        loop--; // 一定要减，不然会一直循环
    }
    // 处理中心元素，当 n 为奇数时
    if (n % 2) {  //n % 2与n % 2 ！= 0 是一样的
        arr[startx][starty] = count;
    }
    return arr;
}
```

**出错的地方：**

- 数组初始化不太会；
- `while (loop)` 这里忘记减loop导致一直循环；
- 四个`for`循环和`startx，starty`不太熟练；
- `arr[startx][starty] = count;`这里的`=`写成了`==`


Java代码如下：

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int num = 1;
        int loop = n / 2; // 要循环n/2次
        int startx = 0; // 每次循环时x和y的起始点都要变
        int starty = 0;
        int offset = 1; // 每次小循环的结束位置
        while(loop > 0){
            int i = startx;
            int j = starty;
            for(; j < n - offset; j++){
                res[startx][j] = num;
                num++;
            }
            for(; i < n - offset; i++){
                res[i][n - 1 - starty] = num;
                num++;
            }
            for(; j > starty; j--){ // 做的时候j>starty而不是>0，如果写到0一定要仔细想一想下次循环是否还是会从0开始
                res[n - 1 - startx][j] = num;
                num++;
            }
            for(; i > startx; i--){
                res[i][starty] = num;
                num++;
            }
            startx++;
            starty++;
            offset++;
            loop--; // 一定要减，不然会循环
        }
        if(n % 2 == 1){
            // res[n / 2][n / 2] = num;
            res[startx][starty] = num;
        }
        return res;
    }
}
```

注意事项：

- 每次循环时x和y的起始点都要变，所以要设置startx和starty；
- 同时每次结束位置也要变，所以要设置偏移量offset；
- loop记得要减，不然会无限循环；
- 写循环时如果写到0一定要仔细想一想下次循环是否还是会从0开始！