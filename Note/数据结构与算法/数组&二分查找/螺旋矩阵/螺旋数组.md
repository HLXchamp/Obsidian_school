![[Pasted image 20240121142056.png|650]]
![[Pasted image 20240121142129.png|409]]

和上一道题差不多，不过这个是读数组中的值，
最主要的是处理**行数列数不相等的情况**，这时候转的圈数应该是行列数较小的一个的一半；
还有一个是怎么处理转完后里面元素的值，因为行列数不相等的话中间不止一个值，就要多一点步骤，先比较`row`与`col`的大小，选小的一个作为条件进行下面的`for`遍历：`if(row <= col && row % 2)`。后面遍历一定要注意是**小于等于**`if(row <= col && row % 2)`。

```c
int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    int row = matrixSize; //行数
    int col = matrixColSize[0]; //列数
    if (row == 0 || col == 0) {
        *returnSize = 0;
        return NULL;
    }
    int *arr = (int *)malloc(row * col * sizeof(int));
    *returnSize = row * col;

    int startx = 0; //起始边，在单圈循环时不变
    int starty = 0;
    int offset = 1;
    int count = 0; //表示arr数组中的下标
    int loop = row < col ? row/2 : col/2; //先选行列数较小的一个，圈数是它的一半
    while(loop){ 
        int i = startx;
        int j = starty;
        for(; j < col - offset; j++){  //注意行row与列col的使用
            arr[count++] = matrix[startx][j];
        }
        for(; i < row - offset; i++){
            arr[count++] = matrix[i][j]; //上一轮的j已经循环到最右边了，可以直接用j
        }
        for(; j > starty; j--){ //此时i和j都是最大值了
            arr[count++] = matrix[i][j]; 
        }
        for(; i > startx; i--){
            arr[count++] = matrix[i][j];
        }
        startx++;
        starty++;
        offset++;
        loop--; //一定要减，不然会一直循环
    }
    if(row <= col && row % 2){ //n % 2与n % 2 ！= 0 是一样的
        for(int j = starty; j <= col - offset; j++){
            arr[count++] = matrix[startx][j];
        }
    }else if(col < row && col % 2){
        for(int i = startx; i <= row - offset; i++){
            arr[count++] = matrix[i][starty];
        }
    }
    return arr;
}
```

**出错的地方：**

- 最后遍历应该是小于等于`j <= col - offset`；
- 最后一定要有一个`row = col`的情况。


Java代码：

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        int row = matrix.length; // 行
        int col = matrix[0].length;
        int loop = col > row ? row / 2 : col / 2; // 循环选行和列最小的那个
        int startx = 0; // 每次循环时x和y的起始点都要变
        int starty = 0;
        int offset = 1; // 每次小循环的结束位置
        while(loop > 0){
            int i = startx;
            int j = starty;
            for(; j < col - offset; j++){
                res.add(matrix[startx][j]);
            }
            for(; i < row - offset; i++){
                res.add(matrix[i][col - 1 - starty]);
            }
            for(; j > starty; j--){ 
                res.add(matrix[row - 1 - startx][j]);
            }
            for(; i > startx; i--){
                res.add(matrix[i][starty]);
            }
            startx++;
            starty++;
            offset++;
            loop--; // 一定要减，不然会循环
        }
        if(row >= col && col % 2 == 1){ // 行>=列，列不变
            for(int i = startx; i <= row - offset; i++){ // 这里是<=，不然会少一个
                res.add(matrix[i][starty]);
            }
        }
        else if(row < col && row % 2 == 1){ // 行<列，行不变
            for(int j = starty; j <= col - offset; j++){ 
                res.add(matrix[startx][j]);
            }
        }
        return res;
    }
}
```
