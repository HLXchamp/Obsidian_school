![[Pasted image 20240117131927.png]]

#### 双指针法

数组其实是有序的， 只不过负数平方之后可能成为最大数了。那么数组平方的**最大值就在数组的两端，不是最左边就是最右边**，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。
如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。


![[977.有序数组的平方.gif|575]]

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize) {
    int* result = (int*)malloc(numsSize * sizeof(int)); //新建一个数组
    *returnSize = numsSize; // 设置返回数组的大小    
    int i = 0;
    int j = numsSize - 1;
    int index = numsSize - 1;
    while(i <= j){
        if(nums[i]*nums[i] < nums[j]*nums[j]){
            result[index--] = nums[j]*nums[j];
            j--;
        }else{
            result[index--] = nums[i]*nums[i];
            i++;
        }
    }
    return result;
    free(result);
}
```

最好新建一个数组用来存放结果，再新建一个索引index，一定要注意判定条件是`i<=j`！

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int slow = 0;
        int fast = nums.length - 1;
        int temp = nums.length - 1;
        int[] res = new int[nums.length];
        while(slow <= fast){
            if(nums[slow] * nums[slow] <= nums[fast] * nums[fast]){
                res[temp] = nums[fast] * nums[fast];
                fast--;
                temp--;
            }
            else{
                res[temp] = nums[slow] * nums[slow];
                slow++;
                temp--;
            }
        }
        return res;
    }
}
```
