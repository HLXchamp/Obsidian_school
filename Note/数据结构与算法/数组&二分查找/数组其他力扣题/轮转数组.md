![[Pasted image 20240709145245.png|525]]

#### 方法一：暴力算法

循环k轮，每次循环都向右移动一位，但会超过时间限制：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        for(int i = 0; i < k; i++){
            int temp = nums[len - 1];
            for(int j = len - 1; j > 0; j--){
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }
}
```

![[Pasted image 20240709145637.png]]

#### 方法二：通过新数组处理移动

用取余运算简化移动操作：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        int[] res = new int[len];
        for(int i = 0; i < len; i++){
            res[(i + k) % len] = nums[i];
        }
        for(int i = 0; i < len; i++){
            nums[i] = res[i];
        }
    }
}
```

注：后面的数组赋值不能用`Arrays.copyOf`等方法！

使用 `Arrays.copyOf(res, len)` 将 `res` 数组的内容复制给 `nums` 数组时，实际上是创建了一个新的数组对象，并将 `res` 数组的元素复制到这个新的数组中。然后，将这个新数组的引用赋值给 `nums` 变量。

这意味着 `nums` 变量将指向一个全新的数组对象，而不是原始的调用者传入的数组。这个新创建的数组与调用者传入的数组不再有任何关联。

- 时间复杂度： O(n)，其中 n 为数组的长度。
- 空间复杂度： O(n)。

#### 方法三：原地移动

从位置0开始，最初令 `temp=nums[0]`。之后位置 0 的元素会放至 `(0+k)modn` 的位置，令 `x=(0+k)modn`，此时交换 `temp` 和 `nums[x]`，完成位置 x 的更新。然后考察位置 x，并交换 `temp` 和 `nums[(x+k)modn]`，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。

使用单独的变量 count 跟踪当前已经访问的元素数量，当 `count=len` 时，结束遍历过程。

![[Pasted image 20240710110044.png]]

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        k = k % len;
        int count = 0;
        for(int i = 0; count < len; i++){
            int cur = i;           // 当前元素的下标
            int prev = nums[cur];  // 当前元素的值
            do {
                int next = (cur + k) % len; // 下一个元素的下标，这里是%len
                int temp = nums[next];      // 下一个元素的值
                nums[next] = prev;
                prev = temp;
                cur = next;
                count++;  // count等于len才说明遍历了所有元素
            } while(cur != i);
        }
    }
}
```

- 时间复杂度：O(n)，其中 n 为数组的长度。每个元素只会被遍历一次。
- 空间复杂度：O(1)。我们只需常数空间存放若干变量。

#### 方法四：数组翻转

![[Pasted image 20240709155630.png|400]]

以后对于数组移动的题都可以考虑一下数组翻转的方法：

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        k = k % len;
        reverse(nums, 0, len - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, len - 1);
    }
    public void reverse(int[] nums, int begin, int end){
        int temp = 0;
        while(begin < end){
            temp = nums[begin];
            nums[begin] = nums[end];
            nums[end] = temp;
            begin++;
            end--;
        }
    }
}
```

注：Java 中数组没有 `reverse` 方法。数组是原始数据类型，不支持像列表（`List`）那样的 `reverse` 方法。

- 时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。
- 空间复杂度：O(1)。