![[Pasted image 20240715095439.png]]
![[Pasted image 20240715095536.png]]
![[Pasted image 20240715095554.png|475]]

#### 解法一：暴力解法

每次通过for循环计算行和列的最大值。

```java
class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
        int len = grid.length;
        int res = 0;
        int temp = 0;
        for(int i = 0; i < len; i++){
            for(int j = 0; j < len; j++){
                temp = Math.min(max(grid, i + 1, 0), max(grid, 0 ,j + 1));
                if(grid[i][j] < temp){
                    res += temp - grid[i][j];
                }
            }
        }
        return res;
    }

    public int max(int[][] grid, int i, int j){
        int len = grid.length;
        int max = 0;
        if(i == 0){
            for(; i < len; i++){
                if(grid[i][j - 1] > max){
                    max = grid[i][j - 1];
                }
            }
            return max; //要放在for循环外，不然一次就返回
        }
        else{
            for(; j < len; j++){
                if(grid[i - 1][j] > max){
                    max = grid[i - 1][j];
                }
            }
            return max;
        }
    }
}
```

#### 解法二：贪心算法

创建两个长度为 n 的数组 rowMax 和 colMax 分别记录矩阵 grid 的每一行的最大值和每一列的最大值。遍历矩阵 grid 填入两个数组之后，再次遍历矩阵，计算每个建筑物高度可以增加的最大值。

```java
class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
        int n = grid.length;
        int[] rowMax = new int[n];
        int[] colMax = new int[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                rowMax[i] = Math.max(rowMax[i], grid[i][j]);
                colMax[j] = Math.max(colMax[j], grid[i][j]);
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                ans += Math.min(rowMax[i], colMax[j]) - grid[i][j];
            }
        }
        return ans;
    }
}
```

 