![[Pasted image 20240710211621.png]]

#### 方法一：用前后缀来乘

![[Pasted image 20240710212007.png|425]]

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] answer = new int[len];
        int[] prefix = new int[len];
        int[] suffix = new int[len];
        prefix[0] = 1;
        suffix[len - 1] = 1;
        for(int i = 1; i < len; i++){
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }
        for(int i = len - 2; i >= 0; i--){   // 这里是>=0
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }
        for(int i = 0; i < len; i++){
            answer[i] = prefix[i] * suffix[i];
        }
        return answer;
    }
}
```

可以简化空间，把后缀直接放在answer数组里：

![[Pasted image 20240710212723.png|450]]

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] answer = new int[len];
        int[] prefix = new int[len];
        int R = 1;
        prefix[0] = 1;
        for(int i = 1; i < len; i++){
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }
        for(int i = len - 1; i >= 0; i--){   // 这里是>=0
            answer[i] = prefix[i] * R;
            R = R * nums[i]; // R后算
        }
        return answer;
    }
}
```

#### 方法二：用回溯法（但不满足时间复杂度O(n)）


```Java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];
        backtrack(nums, answer, 1, 0);
        return answer;
    }
    
    public void backtrack(int[] nums, int[] answer, int product, int index) {
        if (index == nums.length) {
            return;
        }
        for (int i = index; i < nums.length; i++) {
            int num = nums[i];
            answer[i] += product;
            backtrack(nums, answer, product * num, i + 1);
            answer[i] -= product;
        }
    }
}
```
