![[Pasted image 20240307154944.png|675]]
![[Pasted image 20240307154955.png|450]]

有两种方法：一是用哈希表，或者用双指针~

### 哈希解法

两层for循环就可以确定 a 和 b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在数组里出现过，但有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。

把符合条件的三元组放进vector中，然后再去重，这样是非常费时的，很容易超时，也是这道题目通过率如此之低的根源所在。去重的过程不好处理，有很多小细节，如果在面试中很难想到位。

时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。
### 双指针法

**其实这道题目使用哈希法并不十分合适**，因为在去重的操作中有很多细节需要注意，在面试中很难直接写出没有bug的代码。而且使用哈希法在使用两层for循环的时候，能做的剪枝操作很有限，虽然时间复杂度是O(n^2)，也是可以在leetcode上通过，但是程序的执行时间依然比较长 。

接下来是另一个解法：双指针法，**这道题目使用双指针法要比哈希法高效一些**，那么来讲解一下具体实现的思路。

![15.三数之和](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

#### 整体思路

拿这个nums数组来举例，首先将**数组排序**，然后有一层for循环，<font color="#d83931">i</font> 从下标0的地方开始，同时定一个下标 <font color="#d83931">left</font> 定义在`i+1`的位置上，定义下标 <font color="#d83931">right</font> 在数组结尾的位置上。

依然还是在数组中找到 abc 使得`a+b+c=0`，我们这里相当于 `a = nums[i]`，`b = nums[left]`，`c = nums[right]`。

接下来如何移动left 和right呢， 如果`nums[i] + nums[left] + nums[right] > 0` 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

同理，若 `nums[i] + nums[left] + nums[right] < 0` 说明 此时 三数之和小了，left 就向右移动，直到left与right相遇为止。时间复杂度也为O(n^2）。
#### 去重思路

##### a的去重

a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。写法一定是`nums[i] == nums[i - 1]`，拿 i 和 i 的后一个比较；如果是`nums[i] == nums[i + 1]`，那就把三元组中出现重复元素的情况直接pass掉了。 例如`{-1, -1 ,2}`这组数据，当遍历到第一个-1时，判断下一个也是-1，那这组数据就pass了。**不能有重复的三元组，但三元组内的元素是可以重复的！**

```java
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

这是一个非常细节的思考过程。
##### b与c的去重

对 b 和 c 的去重逻辑应该放在找到一个三元组之后！

```java
else{
    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
    // 只有当sum等于0时才移动left和right！！
    while(right > left && nums[right] == nums[right - 1]){
        right--;
    }
    while(left < right && nums[left] == nums[left + 1]){
        left++; // 这里应该是while，因为是持续的过程
    }
    right--;
    left++;
}
```  
#### 具体代码

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 0; i < nums.length - 2; i++){
            if (nums[i] > 0) { 
                return res;
            }
            if(i > 0 && nums[i] == nums[i - 1]){ // 等于是==！
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while(left < right){ // 不能有等号
                int sum = nums[i] + nums[left] + nums[right]; // 求和一定在函数内部！！
                if(sum > 0){
                    right--;
                }
                else if(sum < 0){
                    left++;
                }
                else{
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 只有当sum等于0时才移动left和right！！
                    while(right > left && nums[right] == nums[right - 1]){
                        right--;
                    }
                    while(left < right && nums[left] == nums[left + 1]){
                        left++; // 这里应该是while，因为是持续的过程
                    }
                    right--;
                    left++;
                }
            }   
        }
        return res;
    }
}
```
