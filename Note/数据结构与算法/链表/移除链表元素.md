#### 两种方法：

第一种是**直接删除**，要判断是否删除的节点是头节点，头节点和其他节点的删除方式不一样；

第二种是定义一个**虚拟节点指向头节点**，然后和其他节点删除方式一样。

![[Pasted image 20240123170434.png]]

注意在C和C++删除节点后一定要释放内存，不释放应该也不会出错，不过占用内存会变大。

![[Pasted image 20240123164643.png]]

### C版本

这里采用的是第二种方法，创建了一个`dummy`虚拟节点指向`head`；

```c
struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->next = head;
    struct ListNode* cur = dummy;
    while(cur->next != NULL){
        if(cur->next->val == val){
            cur->next = cur->next->next;
        }
        else{
            cur = cur->next;
        }
    }
    return dummy->next;
}
```

注意事项：

- 要定义一个`cur`临时指针来进行遍历，`dummy`节点不动，它总是指向头节点；
- `cur->next`中间箭头尽量不要分开；
- 最后`return`是`return dummy->next`，也就是头节点。
- 如果要释放删除节点的内存，需新建一个临时节点：

```c
if (cur->next->val == val) {
    struct ListNode* temp = cur->next;
    cur->next = cur->next->next;
    free(temp);  // 释放被删除节点的内存
}
...
struct ListNode* result = dummy->next;
    free(dummy); // 释放创建的 dummy 节点
    return result;
```

### Java版本
#### 方法一：直接删除（不添加虚拟头结点）

要判断删除的节点是否是头结点，是的话直接移动头结点就行：

```java
public ListNode removeElements(ListNode head, int val) {
    while (head != null && head.val == val) {  // 一定要用while
        head = head.next;
    }
    // 已经为null，提前退出
    if (head == null) {
        return head;
    }
    // 已确定当前head.val != val
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```

#### 方法二：添加虚拟头节点（推荐）

添加了虚拟头节点pre最先指向头结点head。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode pre = new ListNode();
        pre.next = head;
        ListNode temp = pre;
        while(head != null){
            if(head.val == val){
                pre.next = head.next;
            }
            else{
                pre = head; // 不删除的话才移动pre
            }
            head = head.next;
            // pre = pre.next; // pre不能这样移动，如果删除了节点，pre移动后就和head重合了
        }

        return temp.next; // 要返回头结点，但此时head已经移动不是头结点了
    }
}
```

注意：

- 不删除的话才移动pre；
- pre移动不能是`pre = pre.next;`应该是`pre = head;`