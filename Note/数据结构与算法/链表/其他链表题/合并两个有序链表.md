![[Pasted image 20240722102502.png]]

#### 方法一：迭代/双指针

链表 l1, l2是递增的，因此容易想到使用双指针 l1和 l2遍历两链表，根据 l1.val 和 l2.val 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。

**引入伪头节点**： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。

![[Pasted image 20240722102928.png|375]]

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode temp1 = list1;
        ListNode temp2 = list2;
        ListNode newHead = new ListNode(0);
        ListNode cur = newHead;
        while (temp1 != null && temp2 != null) {
            if (temp1.val >= temp2.val) { // temp2小，就指向temp2
                cur.next = temp2;
                temp2 = temp2.next; // temp2移动
            } else {
                cur.next = temp1;
                temp1 = temp1.next;
            }
            cur = cur.next;
        }
        if(temp1 != null){ // 将未遍历完的链表连接到合并后的链表末尾
            cur.next = temp1; 
        } else {
            cur.next = temp2;
        }
        return newHead.next;
    }
}
```

- 时间复杂度：**O(n+m)**，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。
- 空间复杂度：**O(1)**,只需要常数的空间存放若干变量。

#### 方法二：递归

这个很难想到，了解一下就行：

如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```
