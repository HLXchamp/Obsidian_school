![[Pasted image 20240722140133.png]]
![[Pasted image 20240722140314.png|386]]

#### 方法一：暴力解法，将链表转化为整数再转化为链表

把链表转化成字符串，然后再翻转转化成整数，接着相加再遍历转化成链表。

注：这里一定要用BigInteger类型，可以表达任意大小的整数，但BigInteger不是基本类型，不能用+-这类操作。

用Long会出现以下错误：

![[Pasted image 20240722140658.png]]


```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
import java.math.BigInteger;
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        BigInteger num1 = linkedListToBigInteger(l1);
        BigInteger num2 = linkedListToBigInteger(l2);
        BigInteger res = num1.add(num2);  // 使用BigInteger的加法

        ListNode dummy = new ListNode(0);  // 虚拟头节点
        ListNode cur = dummy;
        if (res.equals(BigInteger.ZERO)) {
            return new ListNode(0);
        }

        while (!res.equals(BigInteger.ZERO)) {
            int temp = res.mod(BigInteger.TEN).intValue();  // 获取当前最低位的数字
            cur.next = new ListNode(temp);  // 创建新节点
            cur = cur.next;  // 移动到下一个节点
            res = res.divide(BigInteger.TEN);  // 移除当前最低位的数字
        }
        
        return dummy.next;  // 返回链表的头节点
    }

    public BigInteger linkedListToBigInteger(ListNode head) {
        // 使用StringBuilder来构建字符串
        StringBuilder sb = new StringBuilder();
        ListNode cur = head; // 从头节点开始
        while (cur != null) {
            sb.append(cur.val); 
            cur = cur.next; 
        }
        String s = new StringBuilder(sb).reverse().toString();
        return new BigInteger(s);
    }
}
```

- 时间复杂度：**O(max(m, n) + k)**，其中 m 和 n 是两个链表的长度，k 是两个数字长度的较小值。
- 空间复杂度：**O(max(m, n))**，主要取决于 `BigInteger` 存储的数字长度和最终结果链表的长度。

#### 方法二：按位操作，大于10就进位

将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，
比如 `987 + 23 = 987 + 023 = 1010;`
在链表中表达为`7->8->9`与`3->2->0`构成了`0->1->0->1`。

每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值。如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1！

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
import java.math.BigInteger;
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        int sum = 0;
        int carry = 0; // 进位
        int num = 0;   // 个位，存入链表
        while(l1 != null || l2 != null){
            int x = l1 == null ? 0 : l1.val; // 如果l1等于null就当作0来处理
            int y = l2 == null ? 0 : l2.val;
            sum = x + y + carry; 
            carry = sum / 10;
            num = sum % 10;
            cur.next = new ListNode(num);
            cur = cur.next;
            if(l1 != null){ // 判断是否为空，为空就不移动了（没有next）
                l1 = l1.next;
            }
            if(l2 != null){
                l2 = l2.next;
            }
        }
        if(carry == 1){ // 当进位还有值时，例如9 9 + 9=8 0 1，最后有进位一定是1
            cur.next = new ListNode(1);
        }
        return pre.next;
    }
}
```

- 时间复杂度：**O(max(m,n))**，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。
- 空间复杂度：**O(1)**。注意返回值不计入空间复杂度。
