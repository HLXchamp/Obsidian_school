![[Pasted image 20240725112238.png|575]]
![[Pasted image 20240725112254.png|600]]

**进阶：** 你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

### 方法一：双指针比较大小来交换节点

但实现起来太复杂，交换不相邻节点也太复杂。时间复杂度也高于 `O(n log n)` 。

### 方法二：链表转数组后排序，再转成链表

空间复杂度为`O(n)`，且本题考的链表操作，不推荐！

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        ListNode cur = head;
        int[] arr = new int[50000];
        int i = 0;
        while(cur != null){
            arr[i] = cur.val;
            cur = cur.next;
            i++;
        }
        Arrays.sort(arr, 0, i);  // 这里的排序要指定范围，因为数组装不满的话后面全是0
        ListNode dummy = new ListNode(0);
        ListNode p = dummy;
        for(int j = 0; j < i; j++){ // 新建链表
            ListNode temp = new ListNode(arr[j]);
            p.next = temp;
            p = temp;
        }
        return dummy.next;
    }
}
```

- **时间复杂度**：`O(n log n)`，`Arrays.sort`方法时间复杂度可以看作是`O(n log n)`
- **空间复杂度**：`O(n)`

### 方法三：归并排序

![[Pasted image 20240731102851.png|575]]

题目要求时间空间复杂度分别为 `O(nlogn)` 和 `O(1)`，根据时间复杂度我们自然想到二分法，从而联想到归并排序；

通过递归实现链表归并排序，有以下两个环节：

1. 分割 cut 环节： 找到当前链表 中点，并从 中点 将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。
找到中点 slow 后，执行 slow.next = None 将链表切断。
递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。
cut 递归终止条件： 当 head.next == None 时，说明只有一个节点了，直接返回此节点。
2. 合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。
双指针法合并，建立辅助 ListNode h 作为头部。
设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
返回辅助ListNode h 作为头部的下个节点 h.next。
时间复杂度 O(l + r)，l, r 分别代表两个链表长度。

当题目输入的 head == None 时，直接返回 None。


