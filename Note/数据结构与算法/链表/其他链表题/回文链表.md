![[Pasted image 20240718111310.png|675]]

#### 方法一：用栈/数组

每次看到这种回文之类的题，我第一想法都是直接入栈，有相同的就消掉，但还是要根据具体问题具体分析。当然也可以存入数组，再比较头尾是否相等。

##### 错误解法

想的是初始化一个栈，如果栈不为空且当前结点的值与栈顶元素值相等，就抵消（pop一个）。

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode pre = head;
        if(head == null || head.next == null){
            return true;
        }
        Stack<Integer> res = new Stack<>();
        while (pre != null) {  // 偶数个节点
            if (!res.isEmpty() && pre.val == res.peek()) {
                res.pop();
            } else {
                res.push(pre.val);
            }
            pre = pre.next;
        }
        return res.isEmpty();
    }
}
```

但这种方法**没有考虑到奇数节点**的情况：

![[Pasted image 20240719100301.png|80]]

##### 正确解法

把所有元素压入栈，从头结点一个个和栈顶元素比较。此时栈顶元素就是尾节点的值。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode pre = head;
        if(head == null || head.next == null){
            return true;
        }
        Stack<Integer> res = new Stack<>();
        while (pre != null) {  
            res.push(pre.val);
            pre = pre.next;
        }
        pre = head;
        while (pre != null) {  
            if(pre.val != res.pop()){
                return false;
            }
            pre = pre.next;
        }
        return true;
    }
}
```

- 时间复杂度：**O(n)**，其中 n 是链表的长度。代码遍历链表两次，一次用于将值压入栈，一次用于比较。
- 空间复杂度：**O(n)**，需要一个栈来存储链表的值。

#### 解法二：双指针法

主要分为三个步骤：

1. 使用快慢指针找到链表的中点；
2. 反转链表的后半部分；
3. 比较前半部分和反转后的后半部分的节点值。

其中快慢指针找中点如图所示：

![[Pasted image 20240719103150.png|300]]

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode pre = head;
        if(head == null || head.next == null){
            return true;
        }
        // 使用快慢指针找到链表的中点
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null){ // 一定是&&
            slow = slow.next;
            fast = fast.next.next;
        }
        // 从slow开始翻转链表
        ListNode newNode = reverse(slow);
        while(newNode != null){
            if(newNode.val != pre.val){
                return false;
            }
            newNode = newNode.next;
            pre = pre.next;
        }
        return true;
    }

    public ListNode reverse(ListNode head){
        ListNode pre = null; // 防止形成循环引用
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```

- 时间复杂度：**O(n)**，其中 n 是链表的长度。代码遍历链表两次，一次用于找到中点并反转链表，另一次用于比较节点值。
- 空间复杂度：**O(1)** ，只使用了有限的几个额外指针。

最后的链表：

![[Pasted image 20240719111706.png|275]]
