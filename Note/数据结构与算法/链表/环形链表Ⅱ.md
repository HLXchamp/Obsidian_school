![[Pasted image 20240127212738.png]]
![[Pasted image 20240127212947.png|500]]

不仅考察对链表的操作，而且还需要一些数学运算。主要考察两知识点：
- 判断**链表是否有环**
- 如果有环，**如何找到这个环的入口**

#### 判断链表是否有环

使用**快慢指针法**，分别定义 fast 和 slow 指针，从头结点出发，**fast指针每次移动两个节点**，**slow指针每次移动一个节点**，如果 fast 和 slow指针在途中相遇，说明这个链表有环。

**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇；**

因为fast是走两步，slow是走一步，**其实相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

![[141.环形链表.gif]]

且一定是在**slow转的第一圈内相遇**！

![[Pasted image 20240127220517.png|575]]

#### 如果有环，如何找到这个环的入口

假设从头结点 到 环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到 环形入口节点节点数为 z。 如图所示：

![[Pasted image 20240127221712.png|650]]

意思是**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

![[142.环形链表II（求入口）.gif]]

#### C版本

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *fast, *slow;
    fast = head;
    slow = head;
    while(fast && fast->next){ //注意判断条件
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow){
            struct ListNode *index1 = head; //一个从head出发，一个从相遇节点出发
            struct ListNode *index2 = fast;
            while(index1 != index2){ 
                index1 = index1->next;
                index2 = index2->next;
            }
            return index1;
        }
    }
    return NULL;  //无环
}
```

#### Java版本

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null){
            return null;
        }
        ListNode slow = head;
        ListNode fast = head; // 都从haed开始
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(fast == slow){ // 要先移动再判断
                break; // 要跳出循环
            }
        }
        if(fast == null || fast.next == null){ 
            return null;
        }
        slow = head;
        while(fast != slow){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

可以简化：

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == slow) { // 要先移动再判断
                slow = head;
                while (fast != slow) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```
