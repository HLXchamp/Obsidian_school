![[Pasted image 20240127212738.png]]
![[Pasted image 20240127212947.png|500]]

不仅考察对链表的操作，而且还需要一些数学运算。主要考察两知识点：
- 判断**链表是否有环**
- 如果有环，**如何找到这个环的入口**

#### 判断链表是否有环

使用**快慢指针法**，分别定义 fast 和 slow 指针，从头结点出发，**fast指针每次移动两个节点**，**slow指针每次移动一个节点**，如果 fast 和 slow指针在途中相遇，说明这个链表有环。

**fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇；**

因为fast是走两步，slow是走一步，**其实相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

![[141.环形链表.gif]]

且一定是在**slow转的第一圈内相遇**！
![[Pasted image 20240127220517.png|575]]

#### 如果有环，如何找到这个环的入口

假设从头结点 到 环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到 环形入口节点节点数为 z。 如图所示：

![[Pasted image 20240127221712.png|650]]

意思是**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

![[142.环形链表II（求入口）.gif]]

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode *fast, *slow;
    fast = head;
    slow = head;
    while(fast && fast->next){ //注意判断条件
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow){
            struct ListNode *index1 = head; //一个从head出发，一个从相遇节点出发
            struct ListNode *index2 = fast;
            while(index1 != index2){ 
                index1 = index1->next;
                index2 = index2->next;
            }
            return index1;
        }
    }
    return NULL;  //无环
}
```





