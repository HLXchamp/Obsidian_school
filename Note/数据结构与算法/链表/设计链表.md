![[Pasted image 20240123170503.png]]
![[Pasted image 20240124212626.png|575]]

包含了5个重要的函数：
- 获取链表第index个节点的数值
- 在链表的最前面插入一个节点
- 在链表的最后面插入一个节点
- 在链表第index个节点前面插入一个节点
- 删除链表的第index个节点

![[Pasted image 20240124204920.png|625]]

### C版本

注意事项：

- 这个题必须用虚拟头指针，参数都是一级指针，头节点确定后没法改指向了
- 添加节点时，要注意顺序，要先`newNode->next = cur->next;`再`cur->next = newNode;`
- 有索引index时最好用for循环
- 一定要注意判断不能有空指针，也不能索引越界，例如在添加结点时：

```c
 if (cur == NULL) {
        free(newNode);
        return;
    }
```

- 临时变量要free掉 
- 其他细节条件见注释，一定要细心并理清链表的逻辑

```c
typedef struct MyLinkedList{
    int val;
    struct MyLinkedList* next;
} MyLinkedList;

MyLinkedList* myLinkedListCreate() {
    //这个题必须用虚拟头指针,参数都是一级指针,头节点确定后没法改指向了!!!
    MyLinkedList* dummy = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    dummy->next = NULL;
    return dummy;
}

int myLinkedListGet(MyLinkedList* obj, int index) {
    MyLinkedList *cur = obj->next;//这个obj是指向头节点的,cur要用MyLinkedList赋值
    for(int i = 0; cur != NULL; i++){ //这里可以省略i < index
        if(i == index){
            return cur->val;
        }
        else{
            cur = cur->next;
        }
    }
    return -1; //不存在或者链表为空返回-1
}

void myLinkedListAddAtHead(MyLinkedList* obj, int val) {
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val; //不要忘了赋值
    newNode->next = obj->next;
    obj->next = newNode;
}

void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val;
    newNode->next = NULL; //尾节点指向下一个就是NULL
    MyLinkedList *cur = obj;//之后要用cur->next作为循环条件，这里就先不指向next，防止头节点为空
    while(cur->next != NULL){
        cur = cur->next;
    }
    cur->next = newNode;
}

void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
    if(index == 0){
        myLinkedListAddAtHead(obj, val);
        return;
    }
    MyLinkedList* newNode = (MyLinkedList*)malloc(sizeof(MyLinkedList));
    newNode->val = val;
    MyLinkedList *cur = obj;
    while(index && cur != NULL){  //代码随想录里用的for
        cur = cur->next;
        index--;
    }
    if (cur == NULL) {
        // 处理索引越界的情况
        free(newNode);
        return;
    }
    newNode->next = cur->next;
    cur->next = newNode;
}

void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {
    if (index == 0){
        MyLinkedList *temp = obj->next;
        if (temp != NULL){
            obj->next = temp->next;
            free(temp);   //临时变量要free掉  
        }
        return;
    }
    MyLinkedList *cur = obj->next;
    for (int i = 1 ;cur != NULL; i++){ //确保在删除节点时不会越界
        if (i == index){
            MyLinkedList *temp = cur->next;
            if (temp != NULL) {
                cur->next = temp->next;
                free(temp);
            }
            return;
        }
        else{
            cur = cur->next;
        }
    }
}

void myLinkedListFree(MyLinkedList* obj) {
    while(obj != NULL){
        MyLinkedList *temp = obj; //临时指针，释放先前保存的节点的内存
        obj = obj->next;
        free(temp);
    }
}
```

### Java版本

注：

- 这个题必须用虚拟头指针，参数都是一级指针，头节点确定后没法改指向了
- 链表的声明方法要清楚！
#### 单链表

```java
class ListNode {
    int val;
    ListNode next;

    ListNode() {
    } // 无参构造函数
    
    ListNode(int val) { // 有参构造函数
        this.val = val;
    }
}

class MyLinkedList {
    int size; // 存储链表元素的个数
    ListNode dummy;

    public MyLinkedList() {
        size = 0;
        dummy = new ListNode(0); // 新建一个虚拟头节点
    }

    public int get(int index) {
        if (index >= size || index < 0) { // 节点下标从 0 开始
            return -1;
        }
        ListNode pre = dummy;
        for (int i = 0; i <= index; i++) {
            pre = pre.next;
        }
        return pre.val;
    }

    public void addAtHead(int val) {
        addAtIndex(0, val);
    }

    public void addAtTail(int val) {
        addAtIndex(size, val);
    }

    public void addAtIndex(int index, int val) {
        if (index > size) {
            return;
        }
        size++;
        ListNode newNode = new ListNode(val); // 新建一个节点
        if (index == 0) {
            newNode.next = dummy.next;
            dummy.next = newNode;
        } else {
            ListNode pre = dummy;
            for (int i = 0; i < index; i++) {
                pre = pre.next;
            }
            newNode.next = pre.next;
            pre.next = newNode;
        }
    }

    public void deleteAtIndex(int index) {
        if (index >= size) {
            return;
        }
        size--;
        if (index == 0) {
            dummy.next = dummy.next.next;
        } else {
            ListNode pre = dummy;
            for (int i = 0; i < index; i++) {
                pre = pre.next;
            }
            pre.next = pre.next.next;
        }
    }
}
```

#### 双链表

- 双链表多了一个tail，来指向尾节点的虚拟节点；
- 初始化时一定要让head指向tail，tail指向head，不然后面会报空指针异常；
- get查找操作时要判断离head近还是tail近。

```java
//双链表
class ListNode{
    int val;
    ListNode next,prev;
    ListNode() {};
    ListNode(int val){
        this.val = val;
    }
}

class MyLinkedList {  

    //记录链表中元素的数量
    int size;
    //记录链表的虚拟头结点和尾结点
    ListNode head,tail;
    
    public MyLinkedList() {
        //初始化操作
        this.size = 0;
        this.head = new ListNode(0);
        this.tail = new ListNode(0);
        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！
        head.next=tail;
        tail.prev=head;
    }
    
    public int get(int index) {
        //判断index是否有效
        if(index<0 || index>=size){
            return -1;
        }
        ListNode cur = this.head;
        //判断是哪一边遍历时间更短
        if(index >= size / 2){
            //tail开始
            cur = tail;
            for(int i=0; i< size-index; i++){
                cur = cur.prev;
            }
        }else{
            for(int i=0; i<= index; i++){
                cur = cur.next; 
            }
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        //等价于在第0个元素前添加
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        //等价于在最后一个元素(null)前添加
        addAtIndex(size,val);
    }
    
    public void addAtIndex(int index, int val) {
        //index大于链表长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index = 0;
        }
        size++;
        //找到前驱
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        //新建结点
        ListNode newNode = new ListNode(val);
        newNode.next = pre.next;
        pre.next.prev = newNode;
        newNode.prev = pre;
        pre.next = newNode;
        
    }
    
    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0 || index>=size){
            return;
        }
        //删除操作
        size--;
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        pre.next.next.prev = pre;
        pre.next = pre.next.next;
    }
}
```