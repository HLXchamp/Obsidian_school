![[Pasted image 20240125103144.png]]
![[Pasted image 20240125103156.png|450]]

- 最重要的是一定要加一个**虚拟头节点**，要不然之后1节点指向4节点不好操作；
- 最开始定义一个newHead用来表示头节点；
- temp节点用来临时保存；
- 每次循环要挪动dummy和cur节点，temp节点在每次循环中会生成。

![[Pasted image 20240126104514.png|550]]

#### C版本

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {
    struct ListNode *dummy, *cur, *newHead;
    if (head && head->next) {
        dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
        newHead = head->next; //newHead用来表示头节点
        dummy->next = head;
        cur = head;
    } else {
        return head;
    }
    while(cur && cur->next){
       struct ListNode *temp = cur->next;
       cur->next = temp->next; // 一
       temp->next = cur;       // 二
       dummy->next = temp;     // 三
       dummy = cur;            // 四
       cur = cur->next;        // 五
    }
    return newHead;
}
```

#### Java版本

注：
- 可以加一个cur节点来方便操作；
- 第一步一定是`cur.next = temp.next`，不然temp交换后temp.next就没了！

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head; // 用两个指针，处理更方便
        if(head == null || head.next == null){
            return head;
        }
        ListNode newHead = new ListNode(0); // 新定义一个newHead作为交换后的头结点
        newHead = head.next;
        while(cur != null && cur.next != null){ // 是&&
            ListNode temp = cur.next;
            cur.next = temp.next; // 一定是最先这一步，不然temp交换后temp.next就没了
            temp.next = cur;
            dummy.next = temp;
            dummy = cur; // 这个是指向cur，因为cur之前移动了
            cur = cur.next;
        }
        return newHead;
    }
}
```
