![[Pasted image 20240124212945.png|475]]
![[Pasted image 20240124213048.png|550]]
![[Pasted image 20240124213128.png|211]]

如果再定义一个新的链表或者数组，实现链表元素的反转，其实这是对内存空间的浪费。
其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表：

![[Pasted image 20240124213349.png]]
![[206.翻转链表.gif|550]]
（纠正：动画应该是先移动pre，再移动cur）

这里有两个方法，分别是**双指针法**和**递归法**，但思路都是一样的。

- 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null；
- 然后就要开始反转了，首先要把 `cur->next` 节点用temp指针保存一下；
- 保存一下这个节点，是因为接下来要改变` cur->next` 的指向了，将`cur->next` 指向pre ，此时已经反转了第一个节点了；
- 接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针；
- 最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们`return pre`指针就可以了，pre指针就指向了新的头结点。
#### 双指针法：
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode *pre = NULL;
    struct ListNode *cur = head;
    while(cur != NULL){ //也可以直接while(cur)
        struct ListNode *temp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```
- 这里也可以直接操作head，不定义cur；
- `temp` 是一个局部变量，它会在每次循环迭代结束时自动被释放，这里无需手动释放 `temp`；
- 注意结构体的定义`struct ListNode`，要有`struct`；
- 最后结束条件是cur指向NULL，pre指向头节点，所以返回的是pre！
#### 递归法：

同样是当cur为空的时候循环结束，不断将cur指向pre的过程:

```c
struct ListNode* reverse(struct ListNode* pre, struct ListNode* cur) {
    if(!cur)
        return pre;
    struct ListNode* temp = cur->next;
    cur->next = pre;
    //将cur作为pre传入下一层
    //将temp作为cur传入下一层，改变其指针指向当前cur
    return reverse(cur, temp);
}

struct ListNode* reverseList(struct ListNode* head){
    return reverse(NULL, head);
}
```

